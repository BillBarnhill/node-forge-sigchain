// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var Forge, Key, Keyring, Link, UID_HEX_LEN, akatch, athrow, createHash, iced, kbpgp, make_esc, proofs, unix_time, username_to_uid, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  _ref = require('iced-utils').util, athrow = _ref.athrow, akatch = _ref.akatch, unix_time = _ref.unix_time;

  kbpgp = require('kbpgp');

  proofs = require('keybase-proofs');

  createHash = require('crypto').createHash;

  UID_HEX_LEN = 32;

  username_to_uid = function(un) {
    var hashlen;
    hashlen = UID_HEX_LEN - 2;
    return createHash('sha256').update(un).digest('hex').slice(0, hashlen) + "19";
  };

  Key = (function() {
    function Key(_arg) {
      this.km = _arg.km, this.expire_in = _arg.expire_in, this.ctime = _arg.ctime, this.revoked_at = _arg.revoked_at;
    }

    Key.prototype.get_kid = function() {
      return this.km.get_ekid().toString('hex');
    };

    return Key;

  })();

  Link = (function() {
    function Link(_arg) {
      this.linkdesc = _arg.linkdesc, this.proof = _arg.proof, this.generate_res = _arg.generate_res;
    }

    Link.prototype.get_payload_hash = function() {
      return createHash('sha256').update(this.generate_res.json).digest('hex');
    };

    Link.prototype.get_sig_id = function() {
      return this.generate_res.id;
    };

    Link.prototype.to_json = function() {
      return {
        seqno: this.proof.seqno,
        prev: this.proof.prev,
        sig: this.generate_res.armored,
        payload_hash: this.get_payload_hash(),
        sig_id: this.generate_res.id,
        payload_json: this.generate_res.json,
        kid: this.proof.sig_eng.get_km().get_ekid().toString("hex"),
        ctime: this.proof.ctime
      };
    };

    return Link;

  })();

  Keyring = (function() {
    function Keyring() {
      this.bundles = [];
      this.label = {};
    }

    Keyring.prototype.to_json = function() {
      return this.bundles;
    };

    return Keyring;

  })();

  exports.Forge = Forge = (function() {
    function Forge(_arg) {
      this.chain = _arg.chain;
      this._keyring = new Keyring;
      this._links = [];
      this._link_tab = {};
      this._assertions = [];
      this._time = 0;
      this._start = null;
      this._now = null;
      this._expire_in = 0;
      this._seqno = 1;
      this._prev = null;
      this._username = null;
    }

    Forge.prototype._compute_now = function() {
      if (this._now == null) {
        this._now = unix_time();
      }
      return this._now;
    };

    Forge.prototype._get_expire_in = function(_arg) {
      var obj;
      obj = _arg.obj;
      return obj.expire_in || this._expire_in;
    };

    Forge.prototype._make_key = function(_arg, cb) {
      var bundle, esc, k, km, obj, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      km = _arg.km, obj = _arg.obj;
      esc = make_esc(cb, "_make_key");
      k = new Key({
        km: km,
        ctime: this._compute_now(),
        expire_in: this._get_expire_in({
          obj: obj
        })
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._make_key"
          });
          km.export_public({}, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return bundle = arguments[0];
              };
            })(),
            lineno: 94
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._keyring.bundles.push(bundle);
          _this._keyring.label[obj.label] = k;
          return cb(null, k);
        };
      })(this));
    };

    Forge.prototype._compute_time = function(o) {
      var m, ret, sum, term, tmp;
      ret = (function() {
        var _i, _len, _ref1;
        if (typeof o === 'string') {
          if (o === 'now') {
            return this._compute_now();
          } else if (!(m = o.match(/^(\+)?(\d+)$/))) {
            return null;
          } else if (m[1] != null) {
            tmp = this._compute_now() + parseInt(m[2]);
            this._now = tmp;
            return tmp;
          } else {
            return parseInt(m[2]);
          }
        } else if (typeof o !== 'object') {
          return null;
        } else if (o.sum != null) {
          sum = 0;
          _ref1 = o.sum;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            term = _ref1[_i];
            sum += this._compute_time(term);
          }
          return sum;
        } else {
          return null;
        }
      }).call(this);
      if (ret == null) {
        throw new Error("bad time: " + (JSON.stringify(o)));
      }
      return ret;
    };

    Forge.prototype._init = function(cb) {
      var e, err, t;
      try {
        this._start = (t = this.get_chain().time) != null ? this._compute_time(t) : this._compute_now();
        this._expire_in = this.get_chain().expire_in || 60 * 60 * 24 * 364 * 10;
        this._username = this.get_chain().user || "tester_ralph";
        this._uid = this.get_chain().uid || username_to_uid(this._username);
      } catch (_error) {
        e = _error;
        err = e;
      }
      return cb(err);
    };

    Forge.prototype._forge_link = function(_arg, cb) {
      var linkdesc;
      linkdesc = _arg.linkdesc;
      switch (linkdesc.type) {
        case 'eldest':
          return this._forge_eldest_link({
            linkdesc: linkdesc
          }, cb);
        case 'subkey':
          return this._forge_subkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'sibkey':
          return this._forge_sibkey_link({
            linkdesc: linkdesc
          }, cb);
        case 'revoke':
          return this._forge_revoke_link({
            linkdesc: linkdesc
          }, cb);
        default:
          return cb(new Error("unhandled link type: " + linkdesc.type), null);
      }
    };

    Forge.prototype._gen_key = function(_arg, cb) {
      var esc, key, km, obj, required, typ, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      obj = _arg.obj, required = _arg.required;
      esc = make_esc(cb, "_gen_key");
      (function(_this) {
        return (function(__iced_k) {
          var _ref1;
          if ((typ = (_ref1 = obj.key) != null ? _ref1.gen : void 0) != null) {
            (function(__iced_k) {
              switch (typ) {
                case 'eddsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.KeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 150
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'dh':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.kb.EncKeyManager.generate({}, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 152
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                  break;
                case 'pgp_rsa':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.KeyManager.generate_rsa({
                      userid: _this._username
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 154
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                        funcname: "Forge._gen_key"
                      });
                      km.sign({}, esc(__iced_deferrals.defer({
                        lineno: 155
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  });
                  break;
                case 'pgp_ecc':
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    kbpgp.KeyManager.generate_ecc({
                      userid: _this._username
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return km = arguments[0];
                        };
                      })(),
                      lineno: 157
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                        funcname: "Forge._gen_key"
                      });
                      km.sign({}, esc(__iced_deferrals.defer({
                        lineno: 158
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  });
                  break;
                default:
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._gen_key"
                    });
                    athrow(new Error("unknown key type: " + typ), __iced_deferrals.defer({
                      lineno: 160
                    }));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
              }
            })(__iced_k);
          } else {
            (function(__iced_k) {
              if (required) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                    funcname: "Forge._gen_key"
                  });
                  athrow(new Error("Required to generate key but none found"), __iced_deferrals.defer({
                    lineno: 162
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(__iced_k);
          }
        });
      })(this)((function(_this) {
        return function() {
          key = null;
          (function(__iced_k) {
            if (typeof km !== "undefined" && km !== null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._gen_key"
                });
                _this._make_key({
                  km: km,
                  obj: obj
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key = arguments[0];
                    };
                  })(),
                  lineno: 165
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(null, key);
          });
        };
      })(this));
    };

    Forge.prototype._populate_proof = function(_arg) {
      var linkdesc, proof, t;
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      proof.seqno = linkdesc.seqno || this._seqno++;
      proof.prev = linkdesc.prev || this._prev;
      proof.host = "keybase.io";
      proof.user = {
        local: {
          uid: linkdesc.uid || this._uid,
          username: linkdesc.username || this._username
        }
      };
      proof.seq_type = proofs.constants.seq_types.PUBLIC;
      proof.ctime = (t = linkdesc.ctime) != null ? this._compute_time(t) : this._compute_now();
      return proof.expire_in = this._get_expire_in({
        obj: linkdesc
      });
    };

    Forge.prototype._forge_eldest_link = function(_arg, cb) {
      var esc, key, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_eldest_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_eldest_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 186
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          proof = new proofs.Eldest({
            sig_eng: key.km.make_sig_eng()
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
              funcname: "Forge._forge_eldest_link"
            });
            _this._sign_and_commit_link({
              linkdesc: linkdesc,
              proof: proof
            }, esc(__iced_deferrals.defer({
              lineno: 190
            })));
            __iced_deferrals._fulfill();
          })(function() {
            _this._eldest_kid = key.km.get_ekid().toString('hex');
            return cb(null);
          });
        };
      })(this));
    };

    Forge.prototype._forge_subkey_link = function(_arg, cb) {
      var err, esc, key, linkdesc, parent, proof, ref, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_subkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_subkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 198
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          parent = _this._keyring.label[(ref = linkdesc.parent)];
          (function(__iced_k) {
            if (parent == null) {
              err = new Error("Unknown parent '" + ref + "' in link '" + linkdesc.label + "'");
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_subkey_link"
                });
                athrow(err, esc(__iced_deferrals.defer({
                  lineno: 202
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            proof = new proofs.Subkey({
              subkm: key.km,
              sig_eng: parent.km.make_sig_eng(),
              parent_kid: parent.km.get_ekid().toString('hex'),
              eldest_kid: _this._eldest_kid
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_subkey_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 209
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_sibkey_link = function(_arg, cb) {
      var err, esc, key, linkdesc, proof, ref, signer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._forge_sibkey_link"
          });
          _this._gen_key({
            obj: linkdesc,
            required: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return key = arguments[0];
              };
            })(),
            lineno: 216
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          signer = _this._keyring.label[(ref = linkdesc.signer)];
          (function(__iced_k) {
            if (signer == null) {
              err = new Error("Unknown signer '" + ref + "' in link '" + linkdesc.label + "'");
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                  funcname: "Forge._forge_sibkey_link"
                });
                athrow(err, esc(__iced_deferrals.defer({
                  lineno: 220
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            proof = new proofs.Sibkey({
              sibkm: key.km,
              sig_eng: signer.km.make_sig_eng(),
              eldest_kid: _this._eldest_kid
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_sibkey_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 226
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._forge_revoke_link = function(_arg, cb) {
      var a, args, arr, err, errs, esc, id, k, key, label, linkdesc, proof, raw, ref, revoke, signer, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc;
      esc = make_esc(cb, "_forge_sibkey_link");
      signer = this._keyring.label[(ref = linkdesc.signer)];
      (function(_this) {
        return (function(__iced_k) {
          if (signer == null) {
            err = new Error("Unknown parent '" + ref + "' in link '" + linkdesc.label + "'");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_revoke_link"
              });
              athrow(err, esc(__iced_deferrals.defer({
                lineno: 236
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          revoke = {};
          args = {
            sig_eng: signer.km.make_sig_eng(),
            eldest_kid: _this._eldest_kid,
            revoke: revoke
          };
          (function(__iced_k) {
            if ((key = linkdesc.revoke.key) != null) {
              (function(__iced_k) {
                var _ref1;
                if ((revoke.kid = (_ref1 = _this._keyring.label[key]) != null ? _ref1.get_kid() : void 0) == null) {
                  err = new Error("Cannot find key '" + key + "' to revoke in link '" + linkdesc.label + "'");
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                      funcname: "Forge._forge_revoke_link"
                    });
                    athrow(err, esc(__iced_deferrals.defer({
                      lineno: 246
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(__iced_k);
            } else {
              (function(__iced_k) {
                var _i, _len, _ref1;
                if ((arr = linkdesc.revoke.keys) != null) {
                  revoke.kids = [];
                  errs = [];
                  for (_i = 0, _len = arr.length; _i < _len; _i++) {
                    a = arr[_i];
                    if ((k = (_ref1 = _this._keyring.label[a]) != null ? _ref1.get_kid() : void 0) != null) {
                      revoke.kids.push(k);
                    } else {
                      errs.push("Failed to find revoke key '" + a + "' in link '" + linkdesc.label + "'");
                    }
                  }
                  (function(__iced_k) {
                    if (errs.length) {
                      err = new Error(errs.join("; "));
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                          funcname: "Forge._forge_revoke_link"
                        });
                        athrow(err, esc(__iced_deferrals.defer({
                          lineno: 257
                        })));
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    } else {
                      return __iced_k();
                    }
                  })(__iced_k);
                } else {
                  (function(__iced_k) {
                    if ((label = linkdesc.revoke.sig) != null) {
                      (function(__iced_k) {
                        var _ref2;
                        if ((revoke.sig_id = (_ref2 = _this._link_tab[label]) != null ? _ref2.get_sig_id() : void 0) == null) {
                          err = new Error("Cannot find sig '" + label + "' in link '" + linkdesc.label + "'");
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                              funcname: "Forge._forge_revoke_link"
                            });
                            athrow(err, esc(__iced_deferrals.defer({
                              lineno: 261
                            })));
                            __iced_deferrals._fulfill();
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(__iced_k);
                    } else {
                      (function(__iced_k) {
                        var _j, _len1, _ref2;
                        if ((sigs = linkdesc.revoke.sigs) != null) {
                          revoke.sig_ids = [];
                          errs = [];
                          for (_j = 0, _len1 = sigs.length; _j < _len1; _j++) {
                            label = sigs[_j];
                            if ((id = (_ref2 = _this._link_tab[label]) != null ? _ref2.get_sig_id() : void 0) != null) {
                              revoke.sig_ids.push(id);
                            } else {
                              errs.push("Failed to find sig '" + label + "' in link '" + linkdesc.label + "'");
                            }
                          }
                          (function(__iced_k) {
                            if (errs.length) {
                              err = new Error(errs.join("; "));
                              (function(__iced_k) {
                                __iced_deferrals = new iced.Deferrals(__iced_k, {
                                  parent: ___iced_passed_deferral,
                                  filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                                  funcname: "Forge._forge_revoke_link"
                                });
                                athrow(err, esc(__iced_deferrals.defer({
                                  lineno: 272
                                })));
                                __iced_deferrals._fulfill();
                              })(__iced_k);
                            } else {
                              return __iced_k();
                            }
                          })(__iced_k);
                        } else {
                          return __iced_k((raw = linkdesc.revoke.raw) != null ? args.revoke = raw : void 0);
                        }
                      })(__iced_k);
                    }
                  })(__iced_k);
                }
              })(__iced_k);
            }
          })(function() {
            proof = new proofs.Revoke(args);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                funcname: "Forge._forge_revoke_link"
              });
              _this._sign_and_commit_link({
                linkdesc: linkdesc,
                proof: proof
              }, esc(__iced_deferrals.defer({
                lineno: 276
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Forge.prototype._sign_and_commit_link = function(_arg, cb) {
      var esc, generate_res, link, linkdesc, proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      linkdesc = _arg.linkdesc, proof = _arg.proof;
      esc = make_esc(cb, "_sign_and_commit_link");
      this._populate_proof({
        linkdesc: linkdesc,
        proof: proof
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
            funcname: "Forge._sign_and_commit_link"
          });
          proof.generate(esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return generate_res = arguments[0];
              };
            })(),
            lineno: 284
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          link = new Link({
            linkdesc: linkdesc,
            proof: proof,
            generate_res: generate_res
          });
          _this._prev = link.get_payload_hash();
          _this._links.push(link);
          _this._link_tab[linkdesc.label] = link;
          return cb(null);
        };
      })(this));
    };

    Forge.prototype.get_chain = function() {
      return this.chain;
    };

    Forge.prototype.forge = function(cb) {
      var esc, link, linkdesc, out, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Forge::forge");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
            funcname: "Forge.forge"
          });
          _this._init(esc(__iced_deferrals.defer({
            lineno: 299
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            var _i, _len, _ref1, _results, _while;
            _ref1 = _this.get_chain().links;
            _len = _ref1.length;
            _i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++_i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(_i < _len)) {
                return _break();
              } else {
                linkdesc = _ref1[_i];
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/node-forge-sigchain/src/forge.iced",
                    funcname: "Forge.forge"
                  });
                  _this._forge_link({
                    linkdesc: linkdesc
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return out = arguments[0];
                      };
                    })(),
                    lineno: 301
                  })));
                  __iced_deferrals._fulfill();
                })(_next);
              }
            };
            _while(__iced_k);
          })(function() {
            ret = {
              chain: (function() {
                var _i, _len, _ref1, _results;
                _ref1 = this._links;
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  link = _ref1[_i];
                  _results.push(link.to_json());
                }
                return _results;
              }).call(_this),
              keys: _this._keyring.to_json(),
              uid: _this._uid,
              username: _this._username
            };
            return cb(null, ret);
          });
        };
      })(this));
    };

    return Forge;

  })();

}).call(this);
